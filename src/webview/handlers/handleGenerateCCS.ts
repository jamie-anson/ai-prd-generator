// @ts-nocheck
/**
 * @file handleGenerateCCS.ts
 * @description Handles the generation of Code Comprehension Score (CCS) analysis for the current workspace.
 * 
 * The logic of this file is to:
 * 1. Coordinate CCS analysis using modular services
 * 2. Handle webview communication and progress reporting
 * 3. Save analysis results and update UI
 * 4. Provide centralized error handling for CCS generation
 */

import * as vscode from 'vscode';
import { OpenAiService } from '../../utils/openai';
import { handleGenerationError, handleApiError, withErrorHandling } from '../../utils/errorHandler';
import { getCcsOutputPath, ensureOutputDirectory } from '../../utils/configManager';
import { CodebaseAnalysisService } from '../../services/codebaseAnalysisService';
import { CCSPromptTemplate } from '../../templates/ccsPromptTemplate';
import { MarkdownFormatterService } from '../../services/markdownFormatterService';
import { ProjectStateDetector } from '../../utils/projectStateDetector';

/**
 * Logic Step: Handles the 'generate-ccs' message from the webview to generate a Code Comprehension Score analysis.
 * 
 * This function coordinates the entire CCS generation process using modular services:
 * 1. Validates prerequisites (API key, workspace)
 * 2. Uses CodebaseAnalysisService for codebase scanning
 * 3. Uses CCSPromptTemplate for AI prompt generation
 * 4. Uses MarkdownFormatterService for result formatting
 * 5. Saves results and updates the webview
 * 
 * @param message - The message object from the webview (must have command: 'generate-ccs')
 * @param context - The VS Code extension context for accessing secrets and workspace
 * @param webview - The webview instance to post progress and results back to
 * @returns Promise<vscode.Uri | undefined> - The URI of the generated CCS file, or undefined if generation fails
 * 
 * @example
 * ```typescript
 * const result = await handleGenerateCCS(message, context, webview);
 * if (result) {
 *     console.log(`CCS analysis saved to: ${result.fsPath}`);
 * }
 * ```
 */
export async function handleGenerateCCS(message: any, context: vscode.ExtensionContext, webview: vscode.Webview): Promise<vscode.Uri | undefined> {
    if (message.command !== 'generate-ccs') {
        return undefined;
    }

    let generatedPath: vscode.Uri | undefined = undefined;

    await vscode.window.withProgress({ 
        location: vscode.ProgressLocation.Notification, 
        title: "Analyzing Code Comprehension Score...", 
        cancellable: false 
    }, async (progress) => {
        // Logic Step: Validate prerequisites
        const validationResult = await validatePrerequisites(context, webview);
        if (!validationResult) {
            return;
        }

        const { apiKey, workspaceUri } = validationResult;

        // Logic Step: Use error handling wrapper for the entire generation process
        const result = await withErrorHandling(async () => {
            // Logic Step: Analyze the codebase using the dedicated service
            progress.report({ increment: 10, message: "Initializing codebase analysis..." });
            const analysisService = new CodebaseAnalysisService();
            
            progress.report({ increment: 20, message: "Scanning files and directories..." });
            const codebaseAnalysis = await analysisService.analyzeWorkspace(workspaceUri);
            
            // Logic Step: Log analysis summary for debugging
            console.log('CCS Analysis Summary:', analysisService.generateAnalysisSummary(codebaseAnalysis));
            
            // Logic Step: Generate AI prompt using the template service
            progress.report({ increment: 50, message: "Generating AI analysis prompt..." });
            const prompt = CCSPromptTemplate.generatePrompt(codebaseAnalysis);
            
            // Logic Step: Call AI service for analysis
            progress.report({ increment: 60, message: "Calling AI for code analysis..." });
            const openAiService = new OpenAiService(apiKey);
            const rawCcsAnalysis = await openAiService.generateText(prompt);
            
            if (!rawCcsAnalysis) {
                throw new Error('No CCS analysis generated by AI service');
            }

            // Logic Step: Format the analysis results for webview display
            progress.report({ increment: 80, message: "Formatting analysis results..." });
            const formattedAnalysis = MarkdownFormatterService.formatCCSResults(rawCcsAnalysis);
            
            // Logic Step: Save the raw analysis to file
            progress.report({ increment: 85, message: "Saving analysis to file..." });
            const savedFilePath = await saveCCSAnalysis(workspaceUri, rawCcsAnalysis);
            
            // Logic Step: Send the formatted analysis to the webview
            progress.report({ increment: 95, message: "Updating webview..." });
            await webview.postMessage({ 
                command: 'ccsGenerated', 
                analysis: formattedAnalysis,
                filePath: savedFilePath.fsPath
            });

            progress.report({ increment: 100, message: "CCS analysis complete!" });
            return savedFilePath;
        }, 'CCS generation', webview);

        if (result) {
            generatedPath = result;
        }
    });

    return generatedPath;
}

/**
 * Logic Step: Validates prerequisites for CCS generation.
 * 
 * Checks for required conditions before starting analysis:
 * - OpenAI API key availability
 * - Workspace folder existence
 * - Proper error reporting if validation fails
 * 
 * @param context - VS Code extension context for accessing secrets
 * @param webview - Webview for error reporting
 * @returns Promise<{apiKey: string, workspaceUri: vscode.Uri} | null> - Validation result or null if failed
 */
async function validatePrerequisites(context: vscode.ExtensionContext, webview: vscode.Webview): Promise<{apiKey: string, workspaceUri: vscode.Uri} | null> {
    // Logic Step: Check for API key
    const apiKey = await context.secrets.get('openAiApiKey');
    if (!apiKey) {
        handleApiError(
            new Error('OpenAI API Key not set'), 
            'OpenAI', 
            'authentication', 
            webview
        );
        return null;
    }

    // Logic Step: Use ProjectStateDetector to get the correct workspace URI
    const projectState = await ProjectStateDetector.getInstance().detectProjectState();
    if (!projectState.workspaceUri) {
        handleGenerationError(
            new Error('Could not determine the workspace. Please open a file in the desired project.'),
            'CCS generation',
            webview
        );
        return null;
    }

    return {
        apiKey,
        workspaceUri: projectState.workspaceUri
    };
}

/**
 * Logic Step: Saves CCS analysis to a timestamped markdown file.
 * 
 * Creates a new file in the configured CCS output directory with:
 * - Timestamp-based filename for uniqueness
 * - Raw markdown content from AI analysis
 * - Proper error handling for file operations
 * 
 * @param workspaceUri - The workspace root URI for path resolution
 * @param analysisContent - The raw markdown CCS analysis content
 * @returns Promise<vscode.Uri> - URI of the saved file
 * @throws {Error} When file saving fails
 */
async function saveCCSAnalysis(workspaceUri: vscode.Uri, analysisContent: string): Promise<vscode.Uri> {
    try {
        // Logic Step: Ensure output directory exists
        const outputDir = getCcsOutputPath(workspaceUri);
        await ensureOutputDirectory(outputDir);
        
        // Logic Step: Generate unique filename with timestamp
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const ccsFilePath = vscode.Uri.joinPath(outputDir, `ccs-analysis-${timestamp}.md`);
        
        // Logic Step: Write analysis content to file
        await vscode.workspace.fs.writeFile(ccsFilePath, Buffer.from(analysisContent, 'utf-8'));
        
        return ccsFilePath;
    } catch (error) {
        throw new Error(`Failed to save CCS analysis: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
