// @ts-nocheck
/**
 * @file handleCcsDocumentation.ts
 * @description Handles the generation of CCS improvement documentation artifacts.
 */

import * as vscode from 'vscode';
import * as path from 'path';
import { OpenAiService } from '../../utils/openai';
import { handleGenerationError, handleApiError } from '../../utils/errorHandler';
import { CodebaseAnalysisService } from '../../services/codebaseAnalysisService';

async function generateDocumentation(
    context: vscode.ExtensionContext,
    webview: vscode.Webview,
    progressTitle: string,
    promptGenerator: (analysis: any) => string,
    filePathGenerator: (wsPath: string) => { dir: string, full: string, file: string },
    successMessage: string,
    errorContext: string
): Promise<vscode.Uri | undefined> {
    const apiKey = await context.secrets.get('openAiApiKey');
    if (!apiKey) {
        return handleApiError(new Error('OpenAI API Key not set'), 'OpenAI', 'authentication', webview);
    }

    const openAiService = new OpenAiService(apiKey);
    const isApiKeyValid = await openAiService.validateApiKey();
    if (!isApiKeyValid) {
        return handleApiError(new Error('Invalid OpenAI API Key'), 'OpenAI', 'authentication', webview);
    }

    try {
        return await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: progressTitle,
            cancellable: false
        }, async (progress) => {
            progress.report({ message: 'Analyzing codebase...', increment: 20 });

            const analysisService = new CodebaseAnalysisService();
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                throw new Error('No workspace folder found. Please open a project.');
            }

            const codebaseAnalysis = await analysisService.analyzeWorkspace(workspaceFolder.uri.fsPath);
            
            progress.report({ message: 'Generating content with AI...', increment: 40 });

            const prompt = promptGenerator(codebaseAnalysis);
            const generatedContent = await openAiService.generateText(prompt);
            if (!generatedContent) {
                throw new Error(`AI failed to generate ${errorContext} content.`);
            }

            progress.report({ message: 'Saving file...', increment: 30 });

            const paths = filePathGenerator(workspaceFolder.uri.fsPath);
            const fileUri = vscode.Uri.file(paths.full);
            await vscode.workspace.fs.createDirectory(vscode.Uri.file(paths.dir));
            await vscode.workspace.fs.writeFile(fileUri, Buffer.from(generatedContent, 'utf8'));

            progress.report({ message: 'Successfully generated!', increment: 10 });

            const action = await vscode.window.showInformationMessage(successMessage, `Open ${errorContext}`, 'View in Explorer');

            if (action === `Open ${errorContext}`) {
                await vscode.window.showTextDocument(fileUri);
            } else if (action === 'View in Explorer') {
                await vscode.commands.executeCommand('revealInExplorer', fileUri);
            }

            return fileUri;
        });
    } catch (error: any) {
        return handleGenerationError(error, errorContext, webview);
    }
}

export async function handleGenerateComprehensiveReadme(message: any, context: vscode.ExtensionContext, webview: vscode.Webview): Promise<vscode.Uri | undefined> {
    if (message.command !== 'generate-comprehensive-readme') return undefined;
    return generateDocumentation(
        context, webview,
        'Generating Comprehensive README...',
        (analysis) => `Generate a comprehensive README.md for this project to improve Code Comprehension Scores.

Project Analysis:
- Total Files: ${analysis.totalFiles}
- Code Files: ${analysis.codeFiles}
- Languages: ${analysis.languages.join(', ')}
- Directory Structure Depth: ${analysis.maxDepth}
- Has Tests: ${analysis.hasTests}
- Has Documentation: ${analysis.hasDocumentation}
- Has TypeScript: ${analysis.hasTypeScript}

Sample Files:
${analysis.sampleFiles.map(file => `- ${file.relativePath} (${file.language})`).join('\n')}

Create a README.md that includes:
1. **Project Overview** - Clear description of what this project does
2. **Architecture Diagram** - Mermaid diagram showing system components
3. **Quick Start Guide** - Step-by-step setup instructions
4. **Project Structure** - Directory layout explanation
5. **Key Features** - Main functionality highlights
6. **Development Guide** - How to contribute and develop
7. **API Documentation** - If applicable, API endpoints and usage
8. **Testing** - How to run tests and coverage information
9. **Deployment** - Production deployment instructions
10. **Troubleshooting** - Common issues and solutions

Focus on making this README extremely helpful for AI agents and new developers to understand the codebase quickly.
Use Mermaid diagrams where appropriate for visual clarity.
Include specific commands and examples.
Make it comprehensive but well-organized with clear navigation.`,
        (wsPath) => ({ dir: wsPath, full: path.join(wsPath, 'README.md'), file: 'README.md' }),
        'Comprehensive README.md generated successfully!',
        'README.md'
    );
}

export async function handleGenerateCodebaseMap(message: any, context: vscode.ExtensionContext, webview: vscode.Webview): Promise<vscode.Uri | undefined> {
    if (message.command !== 'generate-codebase-map') return undefined;
    return generateDocumentation(
        context, webview,
        'Generating Codebase Map...',
        (analysis) => `Generate a comprehensive CODEBASE_MAP.md for this project to improve Code Comprehension Scores and help AI agents navigate the codebase.

Project Analysis:
- Total Files: ${analysis.totalFiles}
- Code Files: ${analysis.codeFiles}
- Languages: ${analysis.languages.join(', ')}
- Directory Structure Depth: ${analysis.maxDepth}
- Main Directories: ${analysis.sampleFiles.map(f => path.dirname(f.relativePath)).filter((v, i, a) => a.indexOf(v) === i).slice(0, 10).join(', ')}

Sample Files and Structure:
${analysis.sampleFiles.map(file => `- ${file.relativePath} (${file.language}) - ${file.lines} lines`).join('\n')}

Create a CODEBASE_MAP.md that includes:
1. **System Overview** - High-level architecture description
2. **Architecture Diagrams** - Mermaid diagrams showing:
   - System components and their relationships
   - Data flow between components
   - Dependency graphs
3. **Directory Structure** - Complete breakdown of folders and their purposes
4. **Entry Points** - Main application entry points and configuration files
5. **Component Dependencies** - How different parts of the system connect
6. **Integration Points** - External services and API connections
7. **Critical Paths** - Most important code paths for AI agents to understand
8. **Development Workflows** - Common development tasks and procedures
9. **Navigation Guide** - How to find specific functionality
10. **AI Agent Quick Reference** - Specific guidance for AI agents working with this codebase

Focus on creating clear navigation paths and visual diagrams that help AI agents understand the codebase structure and relationships.
Use Mermaid diagrams extensively for visual clarity.
Include specific file paths and component relationships.
Make it a comprehensive guide for understanding the entire system architecture.`,
        (wsPath) => ({ dir: wsPath, full: path.join(wsPath, 'CODEBASE_MAP.md'), file: 'CODEBASE_MAP.md' }),
        'Comprehensive CODEBASE_MAP.md generated successfully!',
        'Codebase Map'
    );
}

export async function handleGenerateTestingFramework(message: any, context: vscode.ExtensionContext, webview: vscode.Webview): Promise<vscode.Uri | undefined> {
    if (message.command !== 'generate-testing-framework') return undefined;
    return generateDocumentation(
        context, webview,
        'Generating Testing Framework...',
        (analysis) => `Generate a comprehensive testing framework for this project to improve Code Comprehension Scores. ...`,
        (wsPath) => ({ dir: path.join(wsPath, 'tests'), full: path.join(wsPath, 'tests', 'README.md'), file: 'README.md' }),
        'Comprehensive testing framework generated successfully!',
        'Testing Framework'
    );
}

export async function handleGenerateAiPromptingGuide(message: any, context: vscode.ExtensionContext, webview: vscode.Webview): Promise<vscode.Uri | undefined> {
    if (message.command !== 'generate-ai-prompting-guide') return undefined;
    return generateDocumentation(
        context, webview,
        'Generating AI Prompting Guide...',
        (analysis) => `Generate a comprehensive AI Agent Prompting Guide for this project to improve Code Comprehension Scores and minimize hallucinations.

                throw new Error('No workspace folder found');
            }

            const codebaseAnalysis = await analysisService.analyzeWorkspace(workspaceFolder.uri.fsPath);
            
            progress.report({ message: 'Generating AI prompting strategies...', increment: 40 });

            // Logic Step: Create AI prompt for comprehensive prompting guide
            const promptingGuidePrompt = `Generate a comprehensive AI Agent Prompting Guide for this project to improve Code Comprehension Scores and minimize hallucinations.

Project Analysis:
- Languages: ${codebaseAnalysis.languages.join(', ')}
- Frameworks: ${codebaseAnalysis.hasTypeScript ? 'TypeScript' : 'JavaScript'}${codebaseAnalysis.hasTests ? ', Testing Framework' : ''}
- Architecture: ${codebaseAnalysis.maxDepth > 3 ? 'Multi-layered' : 'Simple'} (${codebaseAnalysis.maxDepth} levels deep)
- Code Quality: ${codebaseAnalysis.hasTypeScript ? 'Type-safe' : 'Dynamic'}${codebaseAnalysis.hasDocumentation ? ', Documented' : ''}

Create an AI_AGENT_PROMPTING_STRATEGY.md that includes:
1. **Context-First Development** - How AI agents should analyze existing code before making changes
2. **Documentation-Driven Implementation** - Strategies for maintaining comprehensive docs
3. **Test-First Methodology** - How to write tests that serve as living documentation
4. **Code Pattern Recognition** - How to identify and follow existing patterns
5. **Error Prevention Strategies** - Common pitfalls and how to avoid them
6. **Quality Assurance Checklists** - Pre/during/post implementation checks
7. **Integration Guidelines** - How to work with existing systems safely
8. **Performance Considerations** - How to maintain performance while adding features
9. **Security Best Practices** - Security-aware development prompts
10. **Refactoring Strategies** - Safe refactoring approaches for AI agents

Focus on creating prompting strategies that:
- Minimize hallucinations by providing clear context
- Encourage thorough analysis before implementation
- Promote consistent code quality and patterns
- Ensure comprehensive testing and documentation
- Provide specific examples and templates for common scenarios

Make this a practical guide that AI agents can follow to produce high-quality, consistent code.`;

            const promptingGuideContent = await openAiService.generateText(promptingGuidePrompt);

            progress.report({ message: 'Saving AI prompting guide...', increment: 80 });

            // Logic Step: Save AI prompting guide to workspace root
            const promptingGuidePath = vscode.Uri.file(path.join(workspaceFolder.uri.fsPath, 'AI_AGENT_PROMPTING_STRATEGY.md'));
            await vscode.workspace.fs.writeFile(promptingGuidePath, Buffer.from(promptingGuideContent, 'utf-8'));

            progress.report({ message: 'AI prompting guide generated successfully!', increment: 100 });

            // Logic Step: Show success message and offer to open file
            const action = await vscode.window.showInformationMessage(
                'AI Agent Prompting Guide generated successfully!',
                'Open Prompting Guide',
                'View in Explorer'
            );

            if (action === 'Open Prompting Guide') {
                await vscode.window.showTextDocument(promptingGuidePath);
            } else if (action === 'View in Explorer') {
                await vscode.commands.executeCommand('revealInExplorer', promptingGuidePath);

                return promptingGuidePath;
            });
        } catch (error: any) {
            return handleGenerationError(error, 'AI prompting guide generation', webview);
        }
    } catch (error: any) {
        return handleGenerationError(error, 'AI prompting guide generation', webview);
    }
}

/**
 * Logic Step: Generate all CCS documentation artifacts at once.
 * Creates comprehensive documentation suite to maximize CCS score improvements.
 * 
 * @param message - The message object from the webview
 * @param context - The VS Code extension context
 * @param webview - The webview instance for progress updates
 * @returns Promise<vscode.Uri[] | undefined> - Array of URIs for all generated files
 */
export async function handleGenerateAllCcsDocs(
    message: any, 
    context: vscode.ExtensionContext, 
    webview: vscode.Webview
): Promise<vscode.Uri[] | undefined> {
    if (message.command !== 'generate-all-ccs-docs') {
        return undefined;
    }

    return await withErrorHandling(async () => {
        return await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: 'Generating All CCS Documentation...',
            cancellable: false
        }, async (progress) => {
            const generatedFiles: vscode.Uri[] = [];

            progress.report({ message: 'Generating comprehensive README...', increment: 20 });
            const readmeUri = await handleGenerateComprehensiveReadme(
                { command: 'generate-comprehensive-readme' }, 
                context, 
                webview
            );
            if (readmeUri) {generatedFiles.push(readmeUri);}

            progress.report({ message: 'Generating codebase map...', increment: 40 });
            const codebaseMapUri = await handleGenerateCodebaseMap(
                { command: 'generate-codebase-map' }, 
                context, 
                webview
            );
            if (codebaseMapUri) {generatedFiles.push(codebaseMapUri);}

            progress.report({ message: 'Generating testing framework...', increment: 60 });
            const testingFrameworkUri = await handleGenerateTestingFramework(
                { command: 'generate-testing-framework' }, 
                context, 
                webview
            );
            if (testingFrameworkUri) {generatedFiles.push(testingFrameworkUri);}

            progress.report({ message: 'Generating AI prompting guide...', increment: 80 });
            const promptingGuideUri = await handleGenerateAiPromptingGuide(
                { command: 'generate-ai-prompting-guide' }, 
                context, 
                webview
            );
            if (promptingGuideUri) {generatedFiles.push(promptingGuideUri);}

            progress.report({ message: 'All CCS documentation generated successfully!', increment: 100 });

            // Logic Step: Show comprehensive success message
            const action = await vscode.window.showInformationMessage(
                `Successfully generated ${generatedFiles.length} CCS documentation files! Your Code Comprehension Score should be significantly improved.`,
                'Open Workspace',
                'View Files'
            );

            if (action === 'Open Workspace') {
                await vscode.commands.executeCommand('workbench.files.action.refreshFilesExplorer');
            } else if (action === 'View Files') {
                // Open the first generated file
                if (generatedFiles.length > 0) {
                    await vscode.window.showTextDocument(generatedFiles[0]);
                }
            }

            return generatedFiles;
        });
    }, 'All CCS documentation generation', webview);
}
